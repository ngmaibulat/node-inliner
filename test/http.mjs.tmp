import assert from "node:assert";
import { test, describe, beforeEach, afterEach } from "node:test";
import fs from "node:fs";
import path from "node:path";
import nock from "nock";

import inline from "../src/inline.js";

const baseUrl = "http://example.com/";

beforeEach((t) => {
    nock.cleanAll(); // Clean all mocks before each test

    t.diagnostic("baseUrl: " + baseUrl);

    nock(baseUrl)
        .persist()
        .defaultReplyHeaders({
            "Content-Type": "application/octet-stream",
        })
        .get(/.*/)
        .reply((uri) => {
            const relativePath = uri.slice(baseUrl.length).replace(/\?.*/, "");
            const filePath = path.join("cases", relativePath);

            t.diagnostic("filePath: " + filePath);

            if (fs.existsSync(filePath)) {
                const content = fs.readFileSync(filePath);
                const contentType =
                    mime.contentType(path.extname(relativePath)) ||
                    "application/octet-stream";
                return [200, content, { "Content-Type": contentType }];
            } else {
                return [404, "File not found"];
            }
        });
});

afterEach(() => {
    nock.cleanAll();
});

test("should not try to inline empty links", async (t) => {
    const expected = '<link href="" rel="stylesheet" />';

    const res = await fetch(baseUrl + "some/path.css");
    const output = await res.text();
    t.diagnostic("res: " + output);

    const input = {
        fileContent: expected,
        strict: false,
        relativeTo: baseUrl,
    };

    t.diagnostic("content: " + expected);

    inline.html(input, function (err, result) {
        assert.equal(result, expected);
    });
});
